<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pro Space Shooter ‚Äî Ultimate Edition</title>
<style>
  :root{
    --accent: #00f3ff;
    --accent-2: #9b5cff;
    --accent-glow: rgba(0,243,255,0.6);
    --glass-bg: rgba(255,255,255,0.08);
    --glass-border: rgba(255,255,255,0.15);
    --danger: #ff4d6d;
  }
  
  * {
    box-sizing: border-box;
  }
  
  html,body{
    height:100%;
    margin:0;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    background: 
      radial-gradient(circle at 20% 80%, rgba(120,119,198,0.3) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(255,119,198,0.3) 0%, transparent 50%),
      radial-gradient(circle at 40% 40%, rgba(120,219,255,0.2) 0%, transparent 50%),
      linear-gradient(180deg, rgba(0,0,0,0.2), rgba(0,0,0,0.7)),
      url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cg fill='rgba(255,255,255,0.03)' fill-opacity='0.1'%3E%3Ccircle cx='25' cy='25' r='2'/%3E%3Ccircle cx='75' cy='75' r='1.5'/%3E%3Ccircle cx='50' cy='10' r='1'/%3E%3C/g%3E%3C/svg%3E") center/cover fixed;
    color: #eaf9ff;
    overflow:hidden;
  }

  canvas {
    display:block;
    position:relative;
    z-index:1;
    width:100%;
    height:100%;
  }

  /* üé® PREMIUM HUD SYSTEM */
  #hud{
    position:fixed;
    top:20px;
    left:20px;
    z-index:50;
    display:flex;
    flex-direction: column;
    gap:16px;
    pointer-events:none;
  }
  
  .hud-card{
    background: linear-gradient(145deg, rgba(0,0,0,0.4), rgba(255,255,255,0.05));
    backdrop-filter: blur(20px) saturate(180%);
    border:1px solid rgba(255,255,255,0.12);
    padding:16px 20px;
    border-radius:20px;
    display:flex;
    flex-direction: column;
    gap:6px;
    min-width:140px;
    box-shadow: 
      0 12px 40px rgba(0,0,0,0.6), 
      inset 0 1px 0 rgba(255,255,255,0.1),
      0 0 30px rgba(0,243,255,0.1);
    pointer-events:none;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .hud-title{ 
    font-size:14px; 
    color:#fff; 
    font-weight:800;
    letter-spacing: 1px;
    text-transform: uppercase;
    opacity: 0.9;
  }
  
  .hud-value{ 
    font-size:18px; 
    font-weight:900;
    color:#ffffff;
    letter-spacing: 0.5px;
    text-shadow: 0 2px 10px rgba(0,0,0,0.5);
  }
  
  .hud-high{
    font-size:12px;
    color:#ffd700;
    font-weight:700;
    text-shadow: 0 0 10px rgba(255,215,0,0.5);
  }
  
  .wave-info {
    font-size:13px;
    background: linear-gradient(90deg, var(--accent), var(--accent-2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight:800;
    animation: wavePulse 2s infinite;
  }
  
  @keyframes wavePulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  /* ‚ú® POWERUP INDICATORS */
  #powerups {
    position:fixed;
    top:20px;
    right:20px;
    z-index:50;
    display:flex;
    flex-direction: column;
    gap:12px;
    pointer-events:none;
  }
  
  .pup{
    width:64px;
    height:44px;
    border-radius:16px;
    backdrop-filter: blur(25px) saturate(200%);
    background: linear-gradient(145deg, rgba(0,0,0,0.4), rgba(255,255,255,0.06));
    border: 2px solid rgba(255,255,255,0.1);
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 
      0 12px 40px rgba(0,0,0,0.7),
      inset 0 1px 0 rgba(255,255,255,0.1);
    opacity: 0.4;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
  }
  
  .pup.active {
    opacity: 1;
    transform: scale(1.05);
    box-shadow: 
      0 0 40px var(--accent-glow),
      0 20px 60px rgba(0,0,0,0.8),
      inset 0 1px 0 rgba(255,255,255,0.3);
    border-color: var(--accent);
  }
  
  .pup.active.shield { animation: shieldPulse 1.5s infinite; }
  .pup.active.bomb { animation: bombPulse 1s infinite; }

  @keyframes shieldPulse {
    0%, 100% { box-shadow: 0 0 40px var(--accent-glow), 0 20px 60px rgba(0,0,0,0.8); }
    50% { box-shadow: 0 0 60px var(--accent-glow), 0 25px 70px rgba(0,0,0,0.9); }
  }
  
  @keyframes bombPulse {
    0%, 100% { box-shadow: 0 0 30px #ff6666, 0 20px 60px rgba(0,0,0,0.8); }
    50% { box-shadow: 0 0 50px #ff4444, 0 25px 70px rgba(0,0,0,0.9); }
  }

  /* üõ°Ô∏è GAME OVER MODAL */
  #gameOver {
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:200;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(15px);
    opacity: 0;
    visibility: hidden;
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  #gameOver.show {
    opacity: 1;
    visibility: visible;
  }
  
  #gameOver .modal-content {
    min-width:380px;
    padding:48px;
    border-radius:28px;
    text-align:center;
    box-shadow: 
      0 40px 120px rgba(0,0,0,0.9),
      inset 0 1px 0 rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.15);
    background: linear-gradient(180deg, 
      rgba(255,255,255,0.08), 
      rgba(255,255,255,0.02), 
      rgba(0,0,0,0.3));
    backdrop-filter: blur(30px) saturate(200%);
    transform: scale(0.8) rotateX(10deg);
    transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
  }
  
  #gameOver.show .modal-content {
    transform: scale(1) rotateX(0);
  }
  
  #gameOver h1{
    margin:0 0 24px;
    font-size:40px;
    font-weight:900;
    letter-spacing:2px;
    background: linear-gradient(90deg, var(--accent), var(--accent-2), #ffd700);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 0 0 40px rgba(0,243,255,0.5);
  }
  
  #gameOver .score-box{
    margin:24px auto 32px;
    padding:32px;
    border-radius:24px;
    background: linear-gradient(145deg, rgba(0,0,0,0.5), rgba(255,255,255,0.06));
    border:2px solid rgba(255,255,255,0.12);
    width:320px;
    box-shadow: 
      inset 0 1px 0 rgba(255,255,255,0.1),
      0 20px 60px rgba(0,0,0,0.7);
  }
  
  #gameOver .score-box .big{
    font-weight:900;
    font-size:32px;
    letter-spacing:3px;
    margin:8px 0;
    text-shadow: 0 4px 20px rgba(0,0,0,0.8);
  }
  
  #gameOver .high-score {
    color: #ffd700 !important;
    text-shadow: 0 0 25px rgba(255,215,0,0.8);
  }
  
  .btn{
    cursor:pointer;
    border:0;
    padding:16px 32px;
    border-radius:20px;
    font-weight:800;
    font-size:16px;
    color:#031018;
    background: linear-gradient(90deg,var(--accent),var(--accent-2));
    box-shadow:
      0 15px 50px rgba(0,243,255,0.4),
      0 0 40px rgba(0,243,255,0.3),
      inset 0 1px 0 rgba(255,255,255,0.3);
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    text-transform: uppercase;
    letter-spacing: 1px;
    position: relative;
    overflow: hidden;
  }
  
  .btn:hover {
    transform: translateY(-4px) scale(1.05);
    box-shadow:
      0 25px 70px rgba(0,243,255,0.6),
      0 0 60px rgba(0,243,255,0.5),
      inset 0 1px 0 rgba(255,255,255,0.4);
  }

  .controls {
    margin-top:24px;
    font-size:15px;
    opacity:0.9;
    line-height:1.6;
    font-weight:500;
  }
  
  .control-key {
    background: rgba(255,255,255,0.15);
    padding: 4px 8px;
    border-radius: 8px;
    font-weight: 700;
    margin: 0 2px;
    text-shadow: none;
  }

  #help {
    position:fixed;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    z-index:60;
    color:rgba(235,250,255,0.95);
    font-size:14px;
    font-weight:500;
    padding:12px 24px;
    border-radius:16px;
    background: linear-gradient(145deg, rgba(0,0,0,0.4), rgba(255,255,255,0.06));
    border:2px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(20px);
    box-shadow: 0 15px 50px rgba(0,0,0,0.7);
    pointer-events:none;
    white-space: nowrap;
  }

  @media (max-width:800px){
    .hud-card { min-width: 120px; padding: 12px 16px; }
    #gameOver .modal-content { min-width: 320px; padding: 32px; }
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<!-- üéÆ ENHANCED HUD -->
<div id="hud">
  <div class="hud-card">
    <div class="hud-title">SCORE</div>
    <div class="hud-value" id="scoreDisplay">0</div>
  </div>
  
  <div class="hud-card">
    <div class="hud-title">LIVES</div>
    <div class="hud-value" id="livesDisplay">3</div>
  </div>
  
  <div class="hud-card">
    <div class="hud-title">HIGH SCORE</div>
    <div class="hud-value hud-high" id="highScoreDisplay">0</div>
  </div>
  
  <div class="hud-card">
    <div class="hud-title">WAVE</div>
    <div class="hud-value wave-info" id="waveDisplay">1</div>
  </div>
</div>

<!-- ‚ú® POWER-UPS -->
<div id="powerups">
  <div class="pup shield" id="pShield"><span style="font-size:22px;">üõ°Ô∏è</span></div>
  <div class="pup bomb" id="pBomb"><span style="font-size:22px;">üí£</span></div>
</div>

<!-- üõ°Ô∏è GAME OVER MODAL -->
<div id="gameOver">
  <div class="modal-content">
    <h1>MISSION COMPLETE</h1>
    <div class="score-box">
      <div class="big">Score: <span id="finalScore">0</span></div>
      <div class="big high-score">High: <span id="gameHighScore">0</span></div>
    </div>
    <button class="btn" id="restartBtn">RESTART MISSION</button>
    <div class="controls">
      Press <span class="control-key">SPACEBAR</span> or click to restart<br>
      <span class="control-key">‚Üê‚Üí‚Üë‚Üì WASD</span> Move ‚Ä¢ <span class="control-key">B</span> Bomb ‚Ä¢ <span class="control-key">S</span> Shield
    </div>
  </div>
</div>

<div id="help">
  üëâ Arrow Keys/WASD ‚Ä¢ Auto-fire ‚Ä¢ B=Bomb ‚Ä¢ S=Shield ‚Ä¢ SPACE=Restart ‚Ä¢ Difficulty ‚Üë/min!
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

// ---------------- IMAGES ----------------
const shipImg = new Image();
shipImg.src = "spaceship.png"; // ‚úÖ Uses spaceship.png

const invImg = new Image();
invImg.src = "invader.png"; // ‚úÖ Uses invader.png

// ---------------- GAME STATE ----------------
const player = {
    x: canvas.width / 2 - 30,
    y: canvas.height - 150,
    w: 60,
    h: 60,
    vx: 0,
    vy: 0,
    accel: 1.3,
    friction: 0.88,
    maxSpeed: 11,
    hasShield: false,
    shieldTimer: 0,
    shieldAlpha: 0,
    shieldIntensity: 0,
    shieldParticles: []
};

let lives = 3;
let score = 0;
let highScore = parseInt(localStorage.getItem("highScore")) || 0;
let gameActive = true;
let currentWave = 1;
let gameTime = 0;
let hasBombPowerup = false;
let hasShieldPowerup = false;
let bombExplosion = null;

// Arrays
const bullets = [];
const enemies = [];
const enemyBullets = [];
const powerups = [];

// ---------------- BASE VALUES ----------------
let baseWaveSize = 6;
let baseWaveSpeed = 1.4;
let baseShootChance = 0.03;
let waveInterval = 3500;

// ---------------- SHOOTING ----------------
function shoot() {
    if (!gameActive) return;
    bullets.push({
        x: player.x + player.w / 2 - 3,
        y: player.y,
        w: 6,
        h: 12,
        speed: 16
    });
}

setInterval(shoot, 120);

// ---------------- SPAWN WAVES ----------------
function spawnWave() {
    if (!gameActive) return;
    const spacing = Math.max(70, 90 - currentWave * 2);
    let startX = (canvas.width - spacing * getWaveSize()) / 2;

    for (let i = 0; i < getWaveSize(); i++) {
        enemies.push({
            x: startX + i * spacing,
            y: -100 - Math.random() * 70,
            w: 60,
            h: 60,
            speed: getWaveSpeed(),
            shooter: Math.random() < getShootChance()
        });
    }
    currentWave++;
    updateWaveDisplay();
}

setInterval(spawnWave, waveInterval);

// ‚úÖ EQUAL SPAWN RATES - 50/50 Bomb vs Shield
function spawnPowerup() {
    if (!gameActive || Math.random() > 0.4) return;
    
    // PERFECT 50/50 - Same spawn rate for bomb AND shield
    const types = ['bomb', 'shield'];
    const type = types[Math.floor(Math.random() * 2)]; // Exactly 50% each
    
    powerups.push({
        x: Math.random() * (canvas.width - 40),
        y: -40,
        w: 40,
        h: 40,
        type: type,
        speed: 2.5 + Math.random() * 2.5,
        rotation: 0
    });
}

setInterval(spawnPowerup, 6000); // Same interval = same spawn frequency

// ---------------- ENEMY SHOOTING ----------------
setInterval(() => {
    if (!gameActive) return;
    enemies.forEach(e => {
        if (e.shooter && Math.random() < getShootChance() * 1.5) {
            enemyBullets.push({
                x: e.x + e.w / 2,
                y: e.y + e.h,
                w: 6,
                h: 14,
                speed: 6 + currentWave * 0.3
            });
        }
    });
}, 250);

// ---------------- ULTIMATE SHIELD SYSTEM ----------------
function updateShield() {
    if (player.hasShield && player.shieldTimer > 0) {
        player.shieldTimer -= 16;
        player.shieldAlpha = Math.sin(Date.now() * 0.01) * 0.2 + 0.6;
        player.shieldIntensity = Math.max(0, player.shieldIntensity - 0.02);
        
        if (Math.random() < 0.3) {
            player.shieldParticles.push({
                angle: Math.random() * Math.PI * 2,
                dist: player.w/2 + 8,
                life: 1.0,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4
            });
        }
    } else {
        player.hasShield = false;
        player.shieldAlpha *= 0.92;
        player.shieldIntensity *= 0.95;
    }
    
    player.shieldParticles = player.shieldParticles.filter(p => {
        p.life -= 0.03;
        p.dist += 1.5;
        p.vx *= 0.98;
        p.vy *= 0.98;
        return p.life > 0;
    });
}

function drawUltimateShield() {
    if (player.shieldAlpha > 0.05 || player.shieldIntensity > 0.1) {
        const centerX = player.x + player.w/2;
        const centerY = player.y + player.h/2;
        const baseRadius = player.w/2 + 10;
        
        // 3 animated energy rings
        for (let ring = 0; ring < 3; ring++) {
            const radius = baseRadius + ring * 8 + Math.sin(Date.now() * 0.008 + ring) * 6;
            const alpha = (player.shieldAlpha * 0.7 - ring * 0.2) * (1 + player.shieldIntensity);
            
            const outerGrd = ctx.createRadialGradient(centerX, centerY, radius * 0.7, centerX, centerY, radius * 1.4);
            outerGrd.addColorStop(0, `rgba(0,243,255,${alpha})`);
            outerGrd.addColorStop(0.4, `rgba(155,92,255,${alpha * 0.6})`);
            outerGrd.addColorStop(1, `rgba(0,100,200,0)`);
            
            ctx.strokeStyle = outerGrd;
            ctx.lineWidth = 4 + ring * 2;
            ctx.shadowColor = `rgba(0,243,255,${alpha})`;
            ctx.shadowBlur = 25 + ring * 10;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
        
        // Shield hit flash
        if (player.shieldIntensity > 0.1) {
            const flashGrd = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, player.w * 2);
            flashGrd.addColorStop(0, `rgba(255,255,255,${player.shieldIntensity * 0.6})`);
            flashGrd.addColorStop(0.3, `rgba(0,243,255,${player.shieldIntensity * 0.3})`);
            flashGrd.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = flashGrd;
            ctx.beginPath();
            ctx.arc(centerX, centerY, player.w * 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Animated particles
        player.shieldParticles.forEach(p => {
            const px = centerX + Math.cos(p.angle) * p.dist + p.vx;
            const py = centerY + Math.sin(p.angle) * p.dist + p.vy;
            
            const particleGrd = ctx.createRadialGradient(px, py, 0, px, py, 4);
            particleGrd.addColorStop(0, `rgba(0,243,255,${p.life})`);
            particleGrd.addColorStop(1, `rgba(0,243,255,0)`);
            
            ctx.fillStyle = particleGrd;
            ctx.shadowColor = 'rgba(0,243,255,0.8)';
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(px, py, 4 * p.life, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.shadowBlur = 0;
    }
}

// ---------------- BOMB ----------------
function triggerBomb() {
    if (!hasBombPowerup) return;
    
    bombExplosion = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 10,
        alpha: 1
    };

    enemies.length = 0;
    enemyBullets.length = 0;
    score += 50 * currentWave;
    updateScoreDisplay();
    hasBombPowerup = false;
    updatePowerupUI();
}

function drawFireExplosion() {
    if (!bombExplosion) return;
    let e = bombExplosion;

    const grd = ctx.createRadialGradient(e.x, e.y, e.radius * 0.2, e.x, e.y, e.radius);
    grd.addColorStop(0, `rgba(255,200,0,${e.alpha})`);
    grd.addColorStop(0.4, `rgba(255,80,0,${e.alpha})`);
    grd.addColorStop(1, `rgba(70,0,0,0)`);

    ctx.fillStyle = grd;
    ctx.shadowColor = '#ffaa00';
    ctx.shadowBlur = 50;
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    e.radius += 45; 
    e.alpha -= 0.03;
    if (e.alpha <= 0) bombExplosion = null;
}

// ---------------- MOVEMENT ----------------
const keys = {};
window.addEventListener("keydown", e => {
    keys[e.key.toLowerCase()] = true;
    
    if (!gameActive) {
        if (e.key === " " || e.key === "Enter") {
            e.preventDefault();
            restart();
        }
        return;
    }
    
    if (e.key.toLowerCase() === "b") triggerBomb();
    if (e.key.toLowerCase() === "s") activateShield();
});

window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

function smoothMovement() {
    if (keys["arrowleft"] || keys["a"]) player.vx -= player.accel;
    if (keys["arrowright"] || keys["d"]) player.vx += player.accel;
    if (keys["arrowup"] || keys["w"]) player.vy -= player.accel;
    if (keys["arrowdown"] || keys["s"]) player.vy += player.accel;

    player.vx *= player.friction;
    player.vy *= player.friction;

    player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));
    player.vy = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vy));

    player.x += player.vx;
    player.y += player.vy;

    if (player.x < 0) player.x = 0;
    if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
    if (player.y < 0) player.y = 0;
    if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;
}

// ---------------- POWERUPS ----------------
function activateShield() {
    if (!hasShieldPowerup) return;
    player.hasShield = true;
    player.shieldTimer = 10000; // 10 seconds
    hasShieldPowerup = false;
    updatePowerupUI();
}

function updatePowerupUI() {
    document.getElementById("pShield").classList.toggle("active", hasShieldPowerup);
    document.getElementById("pBomb").classList.toggle("active", hasBombPowerup);
}

// ---------------- DIFFICULTY ----------------
function getWaveSize() {
    return Math.min(15, baseWaveSize + Math.floor(gameTime / 60000));
}

function getWaveSpeed() {
    return baseWaveSpeed + (gameTime / 60000) * 0.5;
}

function getShootChance() {
    return Math.min(0.6, baseShootChance + (gameTime / 60000) * 0.08);
}

function updateWaveDisplay() {
    document.getElementById("waveDisplay").textContent = currentWave;
}

// ---------------- COLLISIONS ----------------
function collide(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function checkCollisions() {
    // Player bullets vs enemies
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const b = bullets[bi];
        for (let ei = enemies.length - 1; ei >= 0; ei--) {
            const e = enemies[ei];
            if (collide(b, e)) {
                bullets.splice(bi, 1);
                enemies.splice(ei, 1);
                score += 10 * currentWave;
                updateScoreDisplay();
                break;
            }
        }
    }

    // Powerups vs player
    for (let pi = powerups.length - 1; pi >= 0; pi--) {
        if (collide(player, powerups[pi])) {
            const p = powerups.splice(pi, 1)[0];
            if (p.type === 'bomb') {
                hasBombPowerup = true;
                document.getElementById("pBomb").classList.add("active", "bomb");
            } else if (p.type === 'shield') {
                hasShieldPowerup = true;
                document.getElementById("pShield").classList.add("active", "shield");
            }
        }
    }

    // Enemy bullets vs player
    for (let bi = enemyBullets.length - 1; bi >= 0; bi--) {
        if (collide(enemyBullets[bi], player)) {
            enemyBullets.splice(bi, 1);
            if (player.hasShield) {
                player.hasShield = false;
                player.shieldIntensity = 1.5; // Shield hit flash!
            } else {
                loseLife();
            }
            break;
        }
    }

    // Enemies vs player
    for (let ei = enemies.length - 1; ei >= 0; ei--) {
        if (collide(enemies[ei], player)) {
            enemies.splice(ei, 1);
            if (player.hasShield) {
                player.hasShield = false;
                player.shieldIntensity = 1.5;
            } else {
                loseLife();
            }
            break;
        }
    }
}

function loseLife() {
    lives--;
    updateLivesDisplay();
    if (lives <= 0) gameOver();
}

// ---------------- RENDERING ----------------
function drawPlayer() {
    ctx.save();
    
    // Use spaceship.png if loaded, otherwise fallback
    if (shipImg.complete && shipImg.naturalHeight !== 0) {
        ctx.shadowColor = player.hasShield ? 'cyan' : '#00ff88';
        ctx.shadowBlur = player.hasShield ? 25 : 15;
        ctx.drawImage(shipImg, player.x, player.y, player.w, player.h);
    } else {
        // Fallback ship drawing
        ctx.shadowColor = player.hasShield ? 'cyan' : '#00ff88';
        ctx.shadowBlur = player.hasShield ? 25 : 15;
        ctx.fillStyle = player.hasShield ? '#44ffcc' : '#00ff88';
        ctx.beginPath();
        ctx.moveTo(player.x + player.w/2, player.y);
        ctx.lineTo(player.x, player.y + player.h);
        ctx.lineTo(player.x + player.w/2 - 10, player.y + player.h - 20);
        ctx.lineTo(player.x + player.w/2 + 10, player.y + player.h - 20);
        ctx.lineTo(player.x + player.w, player.y + player.h);
        ctx.closePath();
        ctx.fill();
    }
    
    ctx.shadowBlur = 0;
    ctx.restore();
}

function drawEnemies() {
    enemies.forEach(e => {
        ctx.save();
        
        // Use invader.png if loaded, otherwise fallback
        if (invImg.complete && invImg.naturalHeight !== 0) {
            ctx.shadowColor = '#ff6666';
            ctx.shadowBlur = 12;
            ctx.drawImage(invImg, e.x, e.y, e.w, e.h);
        } else {
            // Fallback enemy drawing
            ctx.shadowColor = '#ff6666';
            ctx.shadowBlur = 12;
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.moveTo(e.x + e.w/2, e.y);
            ctx.lineTo(e.x + e.w, e.y + e.h);
            ctx.lineTo(e.x + e.w/2 + 10, e.y + e.h - 15);
            ctx.lineTo(e.x + e.w/2 - 10, e.y + e.h - 15);
            ctx.lineTo(e.x, e.y + e.h);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.shadowBlur = 0;
        ctx.restore();
    });
}

function drawBullets() {
    ctx.fillStyle = "#ffff00";
    ctx.shadowColor = "yellow";
    ctx.shadowBlur = 10;
    bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
    ctx.shadowBlur = 0;
}

function drawEnemyBullets() {
    ctx.fillStyle = "#ff4444";
    ctx.shadowColor = "red";
    ctx.shadowBlur = 8;
    enemyBullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
    ctx.shadowBlur = 0;
}

function drawPowerups() {
    powerups.forEach(p => {
        ctx.save();
        ctx.translate(p.x + p.w/2, p.y + p.h/2);
        ctx.rotate(p.rotation);
        ctx.shadowColor = p.type === 'bomb' ? '#ff6666' : '#66ffaa';
        ctx.shadowBlur = 20;
        ctx.fillStyle = p.type === 'bomb' ? '#ff4444' : '#44ff88';
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.shadowBlur = 0;
        
        ctx.fillStyle = 'white';
        ctx.font = '28px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(p.type === 'bomb' ? 'üí£' : 'üõ°Ô∏è', 0, 0);
        ctx.restore();
        p.rotation += 0.1;
    });
}

// ---------------- UPDATES ----------------
function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bullets[i].speed;
        if (bullets[i].y < -30) bullets.splice(i, 1);
    }
}

function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].y += enemies[i].speed;
        if (enemies[i].y > canvas.height + 40) enemies.splice(i, 1);
    }
}

function updateEnemyBullets() {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        enemyBullets[i].y += enemyBullets[i].speed;
        if (enemyBullets[i].y > canvas.height + 30) enemyBullets.splice(i, 1);
    }
}

function updatePowerups() {
    for (let i = powerups.length - 1; i >= 0; i--) {
        powerups[i].y += powerups[i].speed;
        powerups[i].rotation += 0.1;
        if (powerups[i].y > canvas.height + 40) powerups.splice(i, 1);
    }
}

function updateScoreDisplay() {
    document.getElementById("scoreDisplay").textContent = score.toLocaleString();
    document.getElementById("livesDisplay").textContent = lives;
    document.getElementById("highScoreDisplay").textContent = highScore.toLocaleString();
}

function updateLivesDisplay() {
    document.getElementById("livesDisplay").textContent = lives;
}

// ---------------- GAME LOOP ----------------
function loop() {
    if (!gameActive) return;
    
    gameTime += 16;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    smoothMovement();
    updateBullets();
    updateEnemies();
    updateEnemyBullets();
    updatePowerups();
    updateShield();
    checkCollisions();

    drawUltimateShield();
    drawPlayer();
    drawBullets();
    drawEnemies();
    drawEnemyBullets();
    drawPowerups();
    drawFireExplosion();

    requestAnimationFrame(loop);
}

// ---------------- MINUTE DIFFICULTY ----------------
setInterval(() => {
    if (!gameActive) return;
    baseWaveSize += 1;
    baseWaveSpeed += 0.3;
    baseShootChance = Math.min(0.5, baseShootChance + 0.04);
    waveInterval = Math.max(1500, waveInterval - 100);
}, 60000);

// ---------------- GAME OVER & RESTART ----------------
function gameOver() {
    gameActive = false;
    if (score > highScore) {
        highScore = score;
        localStorage.setItem("highScore", highScore);
    }
    document.getElementById("finalScore").textContent = score.toLocaleString();
    document.getElementById("gameHighScore").textContent = highScore.toLocaleString();
    document.getElementById("gameOver").classList.add("show");
    updateScoreDisplay();
}

function restart() {
    lives = 3;
    score = 0;
    currentWave = 1;
    gameTime = 0;
    hasBombPowerup = false;
    hasShieldPowerup = false;
    player.hasShield = false;
    player.shieldTimer = 0;
    player.shieldAlpha = 0;
    player.shieldIntensity = 0;
    player.shieldParticles = [];

    baseWaveSize = 6;
    baseWaveSpeed = 1.4;
    baseShootChance = 0.03;
    waveInterval = 3500;

    bullets.length = 0;
    enemies.length = 0;
    enemyBullets.length = 0;
    powerups.length = 0;
    bombExplosion = null;

    player.x = canvas.width / 2 - 30;
    player.y = canvas.height - 150;
    player.vx = 0;
    player.vy = 0;

    gameActive = true;
    document.getElementById("gameOver").classList.remove("show");
    updatePowerupUI();
    updateScoreDisplay();
    updateWaveDisplay();
    loop();
}

// ---------------- EVENT LISTENERS ----------------
document.getElementById("restartBtn").onclick = restart;
document.getElementById("gameOver").onclick = (e) => {
    if (e.target === e.currentTarget) restart();
};

// ---------------- START GAME ----------------
updateScoreDisplay();
updateWaveDisplay();
loop();
</script>
</body>
</html>
